package main

import (
	"fmt"
)

func main() {
	// создан базовый массив длиной 5 элементов типа int, создан срез, указывающий на этот массив с длиной 0
	s := make([]int, 0, 5)
	// в 0-й элемент базового массива записано значение 1; длина среза увеличено на 1 и теперь равно 1
	s = append(s, 1)
	// вывод на экран содержимого среза s: [1]
	fmt.Println("main: ", s)
	// вызов функции, срез передается в функцию по значению
	changeSlice(s)
	// длина среза s после вызова функции не изменилась, ведь в функцию была передана копия среза
	// вывод на экран содержимого среза s: [3]
	fmt.Println("результат: ", s)

	// но значение 10, записанное в базовый массив, по-прежнему находится там, и это можно увидеть
	fmt.Println("куда делось 10? А вот оно лежит в 1-м элементе базового массива: ", s[1:2])
	// можно посмотреть все элменты
	fmt.Println("можно посмотреть на все 5 элементов базового массива: ", s[:5])
	// а посмотреть в память за пределы базового массива не получится
	// зато этот прием можно использовать для завершения своей программы в нужном месте, если os.Exit() мы еще не проходили :)
	fmt.Println("попытаемся заглянуть за пределы массива: ", s[:9223372036854775807])
}
func changeSlice(s []int) {
	// передача среза в функцию выполняется по значению, то есть, сейчас мы работаем с копией среза, но
	// он смотрит на тот же базовый массив
	// в 1-й элемент базового массива записано значение 10,
	s = append(s, 10)
	// в 0-й элемент базового массива записано значение 3
	s[0] = 3
}
