package main

import "fmt"

func main() {
	// создан базовый массив длиной 5 элементов типа int, создан срез, указывающий на этот массив с длиной 4
	s := make([]int, 4, 5)
	// в 4-й элемент базового массива записано значение 1; длина среза увеличено на 1 и теперь равно 5
	s = append(s, 1)
	// вывод на экран содержимого среза s: [0 0 0 0 1]
	fmt.Println("main: ", s)
	// вызов функции, срез передается в функцию по значению
	changeSlice(s)
	// длина среза s после вызова функции не изменилась, т.к. в функцию была передана копия среза
	// не изменился также и указатель на базовый массив, т.е. s по-прежнему хранит указатель на массив длиной 5
	// вывод на экран содержимого среза s: [0 0 0 0 1]
	fmt.Println("результат: ", s)
}
func changeSlice(s []int) {
	// передача среза в функцию выполняется по значению, то есть, сейчас мы работаем с копией среза, но
	// он смотрит на тот же базовый массив

	// т.к. длина базового массива равна 5, и длина среза равна 5, то еще один элемент в базовый массив не помещается.
	// Будет создан новый базовый массив, вероятнее всего, длиной 10*, в его 5-й элемент будет записано значение 10
	// таким образом, срез будет выглядеть так: [0 0 0 0 1 10]
	s = append(s, 10)

	// теперь s указывает на новый базовый массив
	s[0] = 3
	// Почему s[0] = 3 в changeSlice не отработало? Еще как отработало!
	fmt.Println("Почему s[0] = 3 в changeSlice не отработало? Еще как отработало: ", s)
}

// * (алгоритм расчета новой базовой длины не регламентирован в спецификации языка, текущую реализацию
// можно посмотреть в функции runtime.growslice)
